/**
Software License Agreement (BSD)

\file      Ardrone3_setting_callbacks.h
\authors   Mani Monajjemi <mmonajje@sfu.ca>
\copyright Copyright (c) 2015, Autonomy Lab (Simon Fraser University), All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that
the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list of conditions and the
   following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
   following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of Autonomy Lab nor the names of its contributors may be used to endorse or promote
   products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WAR-
RANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, IN-
DIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * Ardrone3_setting_callbacks.h
 * auto-generated from https://raw.githubusercontent.com/Parrot-Developers/libARCommands/5898658a925245555153459ea4684aa87f220e07/Xml/ARDrone3_commands.xml
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */
#ifndef BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H
#define BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_driver/autogenerated/callbacks_common.h"
#include "bebop_driver/BebopArdrone3Config.h"

namespace bebop_driver
{
namespace cb
{

class PilotingSettingsMaxAltitude : public AbstractSetting
{
private:
  double PilotingSettingsMaxAltitudeCurrent_bebop_value_;
  bool PilotingSettingsMaxAltitudeCurrent_bebop_sent_;

public:
  explicit PilotingSettingsMaxAltitude(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED, priv_nh)
      , PilotingSettingsMaxAltitudeCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxAltitudeCurrent != PilotingSettingsMaxAltitudeCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsMaxAltitudeCurrent changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxAltitudeCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsMaxAltitude was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsMaxAltitude changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxAltitude(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxAltitudeCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsMaxAltitude::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMaxAltitudeCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsMaxAltitudeCurrent recved: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxAltitudeCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxAltitudeCurrent exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxAltitudeCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxAltitudeCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsMaxAltitudeCurrent_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsMaxAltitude

class PilotingSettingsMaxTilt : public AbstractSetting
{
private:
  double PilotingSettingsMaxTiltCurrent_bebop_value_;
  bool PilotingSettingsMaxTiltCurrent_bebop_sent_;

public:
  explicit PilotingSettingsMaxTilt(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED, priv_nh)
      , PilotingSettingsMaxTiltCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxTiltCurrent != PilotingSettingsMaxTiltCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsMaxTiltCurrent changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxTiltCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsMaxTilt was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsMaxTilt changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxTilt(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxTiltCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsMaxTilt::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMaxTiltCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsMaxTiltCurrent recved: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxTiltCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxTiltCurrent exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxTiltCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxTiltCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsMaxTiltCurrent_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsMaxTilt

class PilotingSettingsAbsolutControl : public AbstractSetting
{
private:
  int32_t PilotingSettingsAbsolutControlOn_bebop_value_;
  bool PilotingSettingsAbsolutControlOn_bebop_sent_;

public:
  explicit PilotingSettingsAbsolutControl(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED, priv_nh)
      , PilotingSettingsAbsolutControlOn_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsAbsolutControlOn != PilotingSettingsAbsolutControlOn_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsAbsolutControlOn changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsAbsolutControlOn_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsAbsolutControl was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsAbsolutControl changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsAbsolutControl(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsAbsolutControlOn)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsAbsolutControl::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON, arg);
    if (arg)
    {
      PilotingSettingsAbsolutControlOn_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsAbsolutControlOn recved: " << static_cast<int32_t>(arg->value.U8));
      PilotingSettingsAbsolutControlOn_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsAbsolutControlOn exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsAbsolutControlOn"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsAbsolutControlOn", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsAbsolutControlOn_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsAbsolutControl

class PilotingSettingsMaxDistance : public AbstractSetting
{
private:
  double PilotingSettingsMaxDistanceValue_bebop_value_;
  bool PilotingSettingsMaxDistanceValue_bebop_sent_;

public:
  explicit PilotingSettingsMaxDistance(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED, priv_nh)
      , PilotingSettingsMaxDistanceValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxDistanceValue != PilotingSettingsMaxDistanceValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsMaxDistanceValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxDistanceValue_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsMaxDistance was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsMaxDistance changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxDistance(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxDistanceValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsMaxDistance::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    /* UPSTREAMXMLBUG:
     * From: ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_VALUE
     * To: ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT
     * */
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMaxDistanceValue_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsMaxDistanceValue recved: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxDistanceValue_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxDistanceValue exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxDistanceValue"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxDistanceValue", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsMaxDistanceValue_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsMaxDistance

class PilotingSettingsNoFlyOverMaxDistance : public AbstractSetting
{
private:
  int32_t PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_;
  bool PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_;

public:
  explicit PilotingSettingsNoFlyOverMaxDistance(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED, priv_nh)
      , PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover != PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsNoFlyOverMaxDistance was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsNoFlyOverMaxDistance changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsNoFlyOverMaxDistance(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsNoFlyOverMaxDistance::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER, arg);
    if (arg)
    {
      PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover recved: " << static_cast<int32_t>(arg->value.U8));
      PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsNoFlyOverMaxDistance

class SpeedSettingsMaxVerticalSpeed : public AbstractSetting
{
private:
  double SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_;
  bool SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_;

public:
  explicit SpeedSettingsMaxVerticalSpeed(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED, priv_nh)
      , SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsMaxVerticalSpeedCurrent != SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsMaxVerticalSpeedCurrent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsMaxVerticalSpeed was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsMaxVerticalSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxVerticalSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxVerticalSpeedCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsMaxVerticalSpeed::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsMaxVerticalSpeedCurrent recved: " << static_cast<double>(arg->value.Float));
      SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsMaxVerticalSpeedCurrent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsMaxVerticalSpeedCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsMaxVerticalSpeedCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsMaxVerticalSpeedCurrent_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsMaxVerticalSpeed

class SpeedSettingsMaxRotationSpeed : public AbstractSetting
{
private:
  double SpeedSettingsMaxRotationSpeedCurrent_bebop_value_;
  bool SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_;

public:
  explicit SpeedSettingsMaxRotationSpeed(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED, priv_nh)
      , SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsMaxRotationSpeedCurrent != SpeedSettingsMaxRotationSpeedCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsMaxRotationSpeedCurrent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsMaxRotationSpeed was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsMaxRotationSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxRotationSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxRotationSpeedCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsMaxRotationSpeed::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsMaxRotationSpeedCurrent recved: " << static_cast<double>(arg->value.Float));
      SpeedSettingsMaxRotationSpeedCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsMaxRotationSpeedCurrent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsMaxRotationSpeedCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsMaxRotationSpeedCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsMaxRotationSpeedCurrent_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsMaxRotationSpeed

class SpeedSettingsHullProtection : public AbstractSetting
{
private:
  int32_t SpeedSettingsHullProtectionPresent_bebop_value_;
  bool SpeedSettingsHullProtectionPresent_bebop_sent_;

public:
  explicit SpeedSettingsHullProtection(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED, priv_nh)
      , SpeedSettingsHullProtectionPresent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsHullProtectionPresent != SpeedSettingsHullProtectionPresent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsHullProtectionPresent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsHullProtectionPresent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsHullProtection was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsHullProtection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsHullProtection(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsHullProtectionPresent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsHullProtection::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT, arg);
    if (arg)
    {
      SpeedSettingsHullProtectionPresent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsHullProtectionPresent recved: " << static_cast<int32_t>(arg->value.U8));
      SpeedSettingsHullProtectionPresent_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsHullProtectionPresent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsHullProtectionPresent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsHullProtectionPresent", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsHullProtectionPresent_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsHullProtection

class SpeedSettingsOutdoor : public AbstractSetting
{
private:
  int32_t SpeedSettingsOutdoorOutdoor_bebop_value_;
  bool SpeedSettingsOutdoorOutdoor_bebop_sent_;

public:
  explicit SpeedSettingsOutdoor(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED, priv_nh)
      , SpeedSettingsOutdoorOutdoor_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsOutdoorOutdoor != SpeedSettingsOutdoorOutdoor_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsOutdoorOutdoor changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsOutdoorOutdoor_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsOutdoor was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsOutdoor changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsOutdoor(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsOutdoorOutdoor)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsOutdoor::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR, arg);
    if (arg)
    {
      SpeedSettingsOutdoorOutdoor_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsOutdoorOutdoor recved: " << static_cast<int32_t>(arg->value.U8));
      SpeedSettingsOutdoorOutdoor_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsOutdoorOutdoor exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsOutdoorOutdoor"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsOutdoorOutdoor", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsOutdoorOutdoor_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsOutdoor

class NetworkSettingsWifiSelection : public AbstractSetting
{
private:
  int32_t NetworkSettingsWifiSelectionType_bebop_value_;
  bool NetworkSettingsWifiSelectionType_bebop_sent_;
  int32_t NetworkSettingsWifiSelectionBand_bebop_value_;
  bool NetworkSettingsWifiSelectionBand_bebop_sent_;
  int32_t NetworkSettingsWifiSelectionChannel_bebop_value_;
  bool NetworkSettingsWifiSelectionChannel_bebop_sent_;

public:
  explicit NetworkSettingsWifiSelection(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED, priv_nh)
      , NetworkSettingsWifiSelectionType_bebop_sent_(false)
      , NetworkSettingsWifiSelectionBand_bebop_sent_(false)
      , NetworkSettingsWifiSelectionChannel_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionType != NetworkSettingsWifiSelectionType_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "NetworkSettingsWifiSelectionType changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionType_bebop_sent_;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionBand != NetworkSettingsWifiSelectionBand_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "NetworkSettingsWifiSelectionBand changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionBand_bebop_sent_;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionChannel != NetworkSettingsWifiSelectionChannel_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "NetworkSettingsWifiSelectionChannel changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionChannel_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of NetworkSettingsWifiSelection was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending NetworkSettingsWifiSelection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendNetworkSettingsWifiSelection(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE>(config.NetworkSettingsWifiSelectionType)
        , static_cast<eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND>(config.NetworkSettingsWifiSelectionBand)
        , (config.NetworkSettingsWifiSelectionChannel)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "NetworkSettingsWifiSelection::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionType_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for NetworkSettingsWifiSelectionType recved: " << static_cast<int32_t>(arg->value.I32));
      NetworkSettingsWifiSelectionType_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionType exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionType"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionType", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << NetworkSettingsWifiSelectionType_rosparam_value_);
      }
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionBand_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for NetworkSettingsWifiSelectionBand recved: " << static_cast<int32_t>(arg->value.I32));
      NetworkSettingsWifiSelectionBand_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionBand exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionBand"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionBand", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << NetworkSettingsWifiSelectionBand_rosparam_value_);
      }
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionChannel_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for NetworkSettingsWifiSelectionChannel recved: " << static_cast<int32_t>(arg->value.U8));
      NetworkSettingsWifiSelectionChannel_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionChannel exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionChannel"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionChannel", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << NetworkSettingsWifiSelectionChannel_rosparam_value_);
      }
    }
  }
};  // NetworkSettingsWifiSelection

class GPSSettingsHomeType : public AbstractSetting
{
private:
  int32_t GPSSettingsHomeTypeType_bebop_value_;
  bool GPSSettingsHomeTypeType_bebop_sent_;

public:
  explicit GPSSettingsHomeType(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED, priv_nh)
      , GPSSettingsHomeTypeType_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.GPSSettingsHomeTypeType != GPSSettingsHomeTypeType_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "GPSSettingsHomeTypeType changed!");
      changed = true;
    }
    all_inited &= GPSSettingsHomeTypeType_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of GPSSettingsHomeType was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending GPSSettingsHomeType changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendGPSSettingsHomeType(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE>(config.GPSSettingsHomeTypeType)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "GPSSettingsHomeType::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE, arg);
    if (arg)
    {
      GPSSettingsHomeTypeType_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for GPSSettingsHomeTypeType recved: " << static_cast<int32_t>(arg->value.I32));
      GPSSettingsHomeTypeType_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if GPSSettingsHomeTypeType exists in params ...");
      if (!priv_nh_.hasParam("GPSSettingsHomeTypeType"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("GPSSettingsHomeTypeType", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << GPSSettingsHomeTypeType_rosparam_value_);
      }
    }
  }
};  // GPSSettingsHomeType

class GPSSettingsReturnHomeDelay : public AbstractSetting
{
private:
  int32_t GPSSettingsReturnHomeDelayDelay_bebop_value_;
  bool GPSSettingsReturnHomeDelayDelay_bebop_sent_;

public:
  explicit GPSSettingsReturnHomeDelay(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED, priv_nh)
      , GPSSettingsReturnHomeDelayDelay_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.GPSSettingsReturnHomeDelayDelay != GPSSettingsReturnHomeDelayDelay_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "GPSSettingsReturnHomeDelayDelay changed!");
      changed = true;
    }
    all_inited &= GPSSettingsReturnHomeDelayDelay_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of GPSSettingsReturnHomeDelay was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending GPSSettingsReturnHomeDelay changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendGPSSettingsReturnHomeDelay(bebop_ctrl_ptr_->aRDrone3
        , (config.GPSSettingsReturnHomeDelayDelay)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "GPSSettingsReturnHomeDelay::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY, arg);
    if (arg)
    {
      GPSSettingsReturnHomeDelayDelay_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for GPSSettingsReturnHomeDelayDelay recved: " << static_cast<int32_t>(arg->value.U16));
      GPSSettingsReturnHomeDelayDelay_bebop_value_ = static_cast<int32_t>(arg->value.U16);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if GPSSettingsReturnHomeDelayDelay exists in params ...");
      if (!priv_nh_.hasParam("GPSSettingsReturnHomeDelayDelay"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("GPSSettingsReturnHomeDelayDelay", static_cast<int32_t>(arg->value.U16));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << GPSSettingsReturnHomeDelayDelay_rosparam_value_);
      }
    }
  }
};  // GPSSettingsReturnHomeDelay

}  // namespace cb
}  // namespace bebop_driver
#endif  // BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H
