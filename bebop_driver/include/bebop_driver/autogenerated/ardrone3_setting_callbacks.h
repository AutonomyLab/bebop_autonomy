/**
Software License Agreement (BSD)

\file      Ardrone3_setting_callbacks.h
\authors   Mani Monajjemi <mmonajje@sfu.ca>
\copyright Copyright (c) 2015, Autonomy Lab (Simon Fraser University), All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that
the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list of conditions and the
   following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
   following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of Autonomy Lab nor the names of its contributors may be used to endorse or promote
   products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WAR-
RANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, IN-
DIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * Ardrone3_setting_callbacks.h
 * auto-generated from https://raw.githubusercontent.com/Parrot-Developers/arsdk-xml/ab28dab91845cd36c4d7002b55f70805deaff3c8/xml/ardrone3.xml
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */
#ifndef BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H
#define BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_driver/autogenerated/callbacks_common.h"
#include "bebop_driver/BebopArdrone3Config.h"

namespace bebop_driver
{
namespace cb
{

class PilotingSettingsMaxAltitude : public AbstractSetting
{
private:
  double PilotingSettingsMaxAltitudeCurrent_bebop_value_;
  bool PilotingSettingsMaxAltitudeCurrent_bebop_sent_;

public:
  explicit PilotingSettingsMaxAltitude(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED, priv_nh)
      , PilotingSettingsMaxAltitudeCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxAltitudeCurrent != PilotingSettingsMaxAltitudeCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsMaxAltitudeCurrent changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxAltitudeCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsMaxAltitude was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsMaxAltitude changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxAltitude(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxAltitudeCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsMaxAltitude::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMaxAltitudeCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsMaxAltitudeCurrent recved: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxAltitudeCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxAltitudeCurrent exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxAltitudeCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxAltitudeCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsMaxAltitudeCurrent_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsMaxAltitude

class PilotingSettingsMaxTilt : public AbstractSetting
{
private:
  double PilotingSettingsMaxTiltCurrent_bebop_value_;
  bool PilotingSettingsMaxTiltCurrent_bebop_sent_;

public:
  explicit PilotingSettingsMaxTilt(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED, priv_nh)
      , PilotingSettingsMaxTiltCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxTiltCurrent != PilotingSettingsMaxTiltCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsMaxTiltCurrent changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxTiltCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsMaxTilt was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsMaxTilt changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxTilt(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxTiltCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsMaxTilt::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMaxTiltCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsMaxTiltCurrent recved: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxTiltCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxTiltCurrent exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxTiltCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxTiltCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsMaxTiltCurrent_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsMaxTilt

class PilotingSettingsAbsolutControl : public AbstractSetting
{
private:
  int32_t PilotingSettingsAbsolutControlOn_bebop_value_;
  bool PilotingSettingsAbsolutControlOn_bebop_sent_;

public:
  explicit PilotingSettingsAbsolutControl(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED, priv_nh)
      , PilotingSettingsAbsolutControlOn_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsAbsolutControlOn != PilotingSettingsAbsolutControlOn_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsAbsolutControlOn changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsAbsolutControlOn_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsAbsolutControl was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsAbsolutControl changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsAbsolutControl(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsAbsolutControlOn)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsAbsolutControl::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON, arg);
    if (arg)
    {
      PilotingSettingsAbsolutControlOn_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsAbsolutControlOn recved: " << static_cast<int32_t>(arg->value.U8));
      PilotingSettingsAbsolutControlOn_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsAbsolutControlOn exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsAbsolutControlOn"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsAbsolutControlOn", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsAbsolutControlOn_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsAbsolutControl

class PilotingSettingsMaxDistance : public AbstractSetting
{
private:
  double PilotingSettingsMaxDistanceValue_bebop_value_;
  bool PilotingSettingsMaxDistanceValue_bebop_sent_;

public:
  explicit PilotingSettingsMaxDistance(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED, priv_nh)
      , PilotingSettingsMaxDistanceValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMaxDistanceValue != PilotingSettingsMaxDistanceValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsMaxDistanceValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMaxDistanceValue_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsMaxDistance was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsMaxDistance changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMaxDistance(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMaxDistanceValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsMaxDistance::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMaxDistanceValue_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsMaxDistanceValue recved: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMaxDistanceValue_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMaxDistanceValue exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMaxDistanceValue"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMaxDistanceValue", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsMaxDistanceValue_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsMaxDistance

class PilotingSettingsNoFlyOverMaxDistance : public AbstractSetting
{
private:
  int32_t PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_;
  bool PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_;

public:
  explicit PilotingSettingsNoFlyOverMaxDistance(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED, priv_nh)
      , PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover != PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsNoFlyOverMaxDistance was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsNoFlyOverMaxDistance changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsNoFlyOverMaxDistance(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsNoFlyOverMaxDistance::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER, arg);
    if (arg)
    {
      PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover recved: " << static_cast<int32_t>(arg->value.U8));
      PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsNoFlyOverMaxDistanceShouldnotflyover_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsNoFlyOverMaxDistance

class PilotingSettingsBankedTurn : public AbstractSetting
{
private:
  int32_t PilotingSettingsBankedTurnValue_bebop_value_;
  bool PilotingSettingsBankedTurnValue_bebop_sent_;

public:
  explicit PilotingSettingsBankedTurn(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED, priv_nh)
      , PilotingSettingsBankedTurnValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsBankedTurnValue != PilotingSettingsBankedTurnValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsBankedTurnValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsBankedTurnValue_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsBankedTurn was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsBankedTurn changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsBankedTurn(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsBankedTurnValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsBankedTurn::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED_STATE, arg);
    if (arg)
    {
      PilotingSettingsBankedTurnValue_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsBankedTurnValue recved: " << static_cast<int32_t>(arg->value.U8));
      PilotingSettingsBankedTurnValue_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsBankedTurnValue exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsBankedTurnValue"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsBankedTurnValue", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsBankedTurnValue_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsBankedTurn

class PilotingSettingsMinAltitude : public AbstractSetting
{
private:
  double PilotingSettingsMinAltitudeCurrent_bebop_value_;
  bool PilotingSettingsMinAltitudeCurrent_bebop_sent_;

public:
  explicit PilotingSettingsMinAltitude(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED, priv_nh)
      , PilotingSettingsMinAltitudeCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsMinAltitudeCurrent != PilotingSettingsMinAltitudeCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsMinAltitudeCurrent changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsMinAltitudeCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsMinAltitude was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsMinAltitude changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsMinAltitude(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsMinAltitudeCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsMinAltitude::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsMinAltitudeCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsMinAltitudeCurrent recved: " << static_cast<double>(arg->value.Float));
      PilotingSettingsMinAltitudeCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsMinAltitudeCurrent exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsMinAltitudeCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsMinAltitudeCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsMinAltitudeCurrent_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsMinAltitude

class PilotingSettingsCirclingDirection : public AbstractSetting
{
private:
  int32_t PilotingSettingsCirclingDirectionValue_bebop_value_;
  bool PilotingSettingsCirclingDirectionValue_bebop_sent_;

public:
  explicit PilotingSettingsCirclingDirection(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED, priv_nh)
      , PilotingSettingsCirclingDirectionValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsCirclingDirectionValue != PilotingSettingsCirclingDirectionValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsCirclingDirectionValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsCirclingDirectionValue_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsCirclingDirection was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsCirclingDirection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsCirclingDirection(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE>(config.PilotingSettingsCirclingDirectionValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsCirclingDirection::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE, arg);
    if (arg)
    {
      PilotingSettingsCirclingDirectionValue_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsCirclingDirectionValue recved: " << static_cast<int32_t>(arg->value.I32));
      PilotingSettingsCirclingDirectionValue_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsCirclingDirectionValue exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsCirclingDirectionValue"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsCirclingDirectionValue", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsCirclingDirectionValue_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsCirclingDirection

class PilotingSettingsCirclingRadius : public AbstractSetting
{
private:
  int32_t PilotingSettingsCirclingRadiusValue_bebop_value_;
  bool PilotingSettingsCirclingRadiusValue_bebop_sent_;

public:
  explicit PilotingSettingsCirclingRadius(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED, priv_nh)
      , PilotingSettingsCirclingRadiusValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsCirclingRadiusValue != PilotingSettingsCirclingRadiusValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsCirclingRadiusValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsCirclingRadiusValue_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsCirclingRadius was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsCirclingRadius changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsCirclingRadius(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsCirclingRadiusValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsCirclingRadius::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsCirclingRadiusValue_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsCirclingRadiusValue recved: " << static_cast<int32_t>(arg->value.U16));
      PilotingSettingsCirclingRadiusValue_bebop_value_ = static_cast<int32_t>(arg->value.U16);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsCirclingRadiusValue exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsCirclingRadiusValue"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsCirclingRadiusValue", static_cast<int32_t>(arg->value.U16));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsCirclingRadiusValue_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsCirclingRadius

class PilotingSettingsCirclingAltitude : public AbstractSetting
{
private:
  int32_t PilotingSettingsCirclingAltitudeValue_bebop_value_;
  bool PilotingSettingsCirclingAltitudeValue_bebop_sent_;

public:
  explicit PilotingSettingsCirclingAltitude(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED, priv_nh)
      , PilotingSettingsCirclingAltitudeValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsCirclingAltitudeValue != PilotingSettingsCirclingAltitudeValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsCirclingAltitudeValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsCirclingAltitudeValue_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsCirclingAltitude was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsCirclingAltitude changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsCirclingAltitude(bebop_ctrl_ptr_->aRDrone3
        , (config.PilotingSettingsCirclingAltitudeValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsCirclingAltitude::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_CURRENT, arg);
    if (arg)
    {
      PilotingSettingsCirclingAltitudeValue_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsCirclingAltitudeValue recved: " << static_cast<int32_t>(arg->value.U16));
      PilotingSettingsCirclingAltitudeValue_bebop_value_ = static_cast<int32_t>(arg->value.U16);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsCirclingAltitudeValue exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsCirclingAltitudeValue"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsCirclingAltitudeValue", static_cast<int32_t>(arg->value.U16));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsCirclingAltitudeValue_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsCirclingAltitude

class PilotingSettingsPitchMode : public AbstractSetting
{
private:
  int32_t PilotingSettingsPitchModeValue_bebop_value_;
  bool PilotingSettingsPitchModeValue_bebop_sent_;

public:
  explicit PilotingSettingsPitchMode(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED, priv_nh)
      , PilotingSettingsPitchModeValue_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PilotingSettingsPitchModeValue != PilotingSettingsPitchModeValue_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PilotingSettingsPitchModeValue changed!");
      changed = true;
    }
    all_inited &= PilotingSettingsPitchModeValue_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PilotingSettingsPitchMode was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PilotingSettingsPitchMode changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPilotingSettingsPitchMode(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE>(config.PilotingSettingsPitchModeValue)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PilotingSettingsPitchMode::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE, arg);
    if (arg)
    {
      PilotingSettingsPitchModeValue_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PilotingSettingsPitchModeValue recved: " << static_cast<int32_t>(arg->value.I32));
      PilotingSettingsPitchModeValue_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PilotingSettingsPitchModeValue exists in params ...");
      if (!priv_nh_.hasParam("PilotingSettingsPitchModeValue"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PilotingSettingsPitchModeValue", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PilotingSettingsPitchModeValue_rosparam_value_);
      }
    }
  }
};  // PilotingSettingsPitchMode

class SpeedSettingsMaxVerticalSpeed : public AbstractSetting
{
private:
  double SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_;
  bool SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_;

public:
  explicit SpeedSettingsMaxVerticalSpeed(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED, priv_nh)
      , SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsMaxVerticalSpeedCurrent != SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsMaxVerticalSpeedCurrent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsMaxVerticalSpeed was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsMaxVerticalSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxVerticalSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxVerticalSpeedCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsMaxVerticalSpeed::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      SpeedSettingsMaxVerticalSpeedCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsMaxVerticalSpeedCurrent recved: " << static_cast<double>(arg->value.Float));
      SpeedSettingsMaxVerticalSpeedCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsMaxVerticalSpeedCurrent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsMaxVerticalSpeedCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsMaxVerticalSpeedCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsMaxVerticalSpeedCurrent_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsMaxVerticalSpeed

class SpeedSettingsMaxRotationSpeed : public AbstractSetting
{
private:
  double SpeedSettingsMaxRotationSpeedCurrent_bebop_value_;
  bool SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_;

public:
  explicit SpeedSettingsMaxRotationSpeed(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED, priv_nh)
      , SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsMaxRotationSpeedCurrent != SpeedSettingsMaxRotationSpeedCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsMaxRotationSpeedCurrent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsMaxRotationSpeed was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsMaxRotationSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxRotationSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxRotationSpeedCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsMaxRotationSpeed::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      SpeedSettingsMaxRotationSpeedCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsMaxRotationSpeedCurrent recved: " << static_cast<double>(arg->value.Float));
      SpeedSettingsMaxRotationSpeedCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsMaxRotationSpeedCurrent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsMaxRotationSpeedCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsMaxRotationSpeedCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsMaxRotationSpeedCurrent_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsMaxRotationSpeed

class SpeedSettingsHullProtection : public AbstractSetting
{
private:
  int32_t SpeedSettingsHullProtectionPresent_bebop_value_;
  bool SpeedSettingsHullProtectionPresent_bebop_sent_;

public:
  explicit SpeedSettingsHullProtection(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED, priv_nh)
      , SpeedSettingsHullProtectionPresent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsHullProtectionPresent != SpeedSettingsHullProtectionPresent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsHullProtectionPresent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsHullProtectionPresent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsHullProtection was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsHullProtection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsHullProtection(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsHullProtectionPresent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsHullProtection::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT, arg);
    if (arg)
    {
      SpeedSettingsHullProtectionPresent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsHullProtectionPresent recved: " << static_cast<int32_t>(arg->value.U8));
      SpeedSettingsHullProtectionPresent_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsHullProtectionPresent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsHullProtectionPresent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsHullProtectionPresent", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsHullProtectionPresent_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsHullProtection

class SpeedSettingsOutdoor : public AbstractSetting
{
private:
  int32_t SpeedSettingsOutdoorOutdoor_bebop_value_;
  bool SpeedSettingsOutdoorOutdoor_bebop_sent_;

public:
  explicit SpeedSettingsOutdoor(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED, priv_nh)
      , SpeedSettingsOutdoorOutdoor_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsOutdoorOutdoor != SpeedSettingsOutdoorOutdoor_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsOutdoorOutdoor changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsOutdoorOutdoor_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsOutdoor was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsOutdoor changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsOutdoor(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsOutdoorOutdoor)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsOutdoor::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR, arg);
    if (arg)
    {
      SpeedSettingsOutdoorOutdoor_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsOutdoorOutdoor recved: " << static_cast<int32_t>(arg->value.U8));
      SpeedSettingsOutdoorOutdoor_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsOutdoorOutdoor exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsOutdoorOutdoor"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsOutdoorOutdoor", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsOutdoorOutdoor_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsOutdoor

class SpeedSettingsMaxPitchRollRotationSpeed : public AbstractSetting
{
private:
  double SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_value_;
  bool SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_sent_;

public:
  explicit SpeedSettingsMaxPitchRollRotationSpeed(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED, priv_nh)
      , SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.SpeedSettingsMaxPitchRollRotationSpeedCurrent != SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "SpeedSettingsMaxPitchRollRotationSpeedCurrent changed!");
      changed = true;
    }
    all_inited &= SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of SpeedSettingsMaxPitchRollRotationSpeed was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending SpeedSettingsMaxPitchRollRotationSpeed changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendSpeedSettingsMaxPitchRollRotationSpeed(bebop_ctrl_ptr_->aRDrone3
        , (config.SpeedSettingsMaxPitchRollRotationSpeedCurrent)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "SpeedSettingsMaxPitchRollRotationSpeed::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_CURRENT, arg);
    if (arg)
    {
      SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for SpeedSettingsMaxPitchRollRotationSpeedCurrent recved: " << static_cast<double>(arg->value.Float));
      SpeedSettingsMaxPitchRollRotationSpeedCurrent_bebop_value_ = static_cast<double>(arg->value.Float);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if SpeedSettingsMaxPitchRollRotationSpeedCurrent exists in params ...");
      if (!priv_nh_.hasParam("SpeedSettingsMaxPitchRollRotationSpeedCurrent"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("SpeedSettingsMaxPitchRollRotationSpeedCurrent", static_cast<double>(arg->value.Float));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << SpeedSettingsMaxPitchRollRotationSpeedCurrent_rosparam_value_);
      }
    }
  }
};  // SpeedSettingsMaxPitchRollRotationSpeed

class NetworkSettingsWifiSelection : public AbstractSetting
{
private:
  int32_t NetworkSettingsWifiSelectionType_bebop_value_;
  bool NetworkSettingsWifiSelectionType_bebop_sent_;
  int32_t NetworkSettingsWifiSelectionBand_bebop_value_;
  bool NetworkSettingsWifiSelectionBand_bebop_sent_;
  int32_t NetworkSettingsWifiSelectionChannel_bebop_value_;
  bool NetworkSettingsWifiSelectionChannel_bebop_sent_;

public:
  explicit NetworkSettingsWifiSelection(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED, priv_nh)
      , NetworkSettingsWifiSelectionType_bebop_sent_(false)
      , NetworkSettingsWifiSelectionBand_bebop_sent_(false)
      , NetworkSettingsWifiSelectionChannel_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionType != NetworkSettingsWifiSelectionType_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "NetworkSettingsWifiSelectionType changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionType_bebop_sent_;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionBand != NetworkSettingsWifiSelectionBand_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "NetworkSettingsWifiSelectionBand changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionBand_bebop_sent_;

    // This will likely fail for float or double values
    if ((config.NetworkSettingsWifiSelectionChannel != NetworkSettingsWifiSelectionChannel_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "NetworkSettingsWifiSelectionChannel changed!");
      changed = true;
    }
    all_inited &= NetworkSettingsWifiSelectionChannel_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of NetworkSettingsWifiSelection was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending NetworkSettingsWifiSelection changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendNetworkSettingsWifiSelection(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE>(config.NetworkSettingsWifiSelectionType)
        , static_cast<eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND>(config.NetworkSettingsWifiSelectionBand)
        , (config.NetworkSettingsWifiSelectionChannel)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "NetworkSettingsWifiSelection::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionType_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for NetworkSettingsWifiSelectionType recved: " << static_cast<int32_t>(arg->value.I32));
      NetworkSettingsWifiSelectionType_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionType exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionType"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionType", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << NetworkSettingsWifiSelectionType_rosparam_value_);
      }
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionBand_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for NetworkSettingsWifiSelectionBand recved: " << static_cast<int32_t>(arg->value.I32));
      NetworkSettingsWifiSelectionBand_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionBand exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionBand"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionBand", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << NetworkSettingsWifiSelectionBand_rosparam_value_);
      }
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL, arg);
    if (arg)
    {
      NetworkSettingsWifiSelectionChannel_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for NetworkSettingsWifiSelectionChannel recved: " << static_cast<int32_t>(arg->value.U8));
      NetworkSettingsWifiSelectionChannel_bebop_value_ = static_cast<int32_t>(arg->value.U8);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if NetworkSettingsWifiSelectionChannel exists in params ...");
      if (!priv_nh_.hasParam("NetworkSettingsWifiSelectionChannel"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("NetworkSettingsWifiSelectionChannel", static_cast<int32_t>(arg->value.U8));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << NetworkSettingsWifiSelectionChannel_rosparam_value_);
      }
    }
  }
};  // NetworkSettingsWifiSelection

class PictureSettingsVideoStabilizationMode : public AbstractSetting
{
private:
  int32_t PictureSettingsVideoStabilizationModeMode_bebop_value_;
  bool PictureSettingsVideoStabilizationModeMode_bebop_sent_;

public:
  explicit PictureSettingsVideoStabilizationMode(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED, priv_nh)
      , PictureSettingsVideoStabilizationModeMode_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PictureSettingsVideoStabilizationModeMode != PictureSettingsVideoStabilizationModeMode_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PictureSettingsVideoStabilizationModeMode changed!");
      changed = true;
    }
    all_inited &= PictureSettingsVideoStabilizationModeMode_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PictureSettingsVideoStabilizationMode was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PictureSettingsVideoStabilizationMode changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPictureSettingsVideoStabilizationMode(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE>(config.PictureSettingsVideoStabilizationModeMode)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PictureSettingsVideoStabilizationMode::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE, arg);
    if (arg)
    {
      PictureSettingsVideoStabilizationModeMode_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PictureSettingsVideoStabilizationModeMode recved: " << static_cast<int32_t>(arg->value.I32));
      PictureSettingsVideoStabilizationModeMode_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PictureSettingsVideoStabilizationModeMode exists in params ...");
      if (!priv_nh_.hasParam("PictureSettingsVideoStabilizationModeMode"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PictureSettingsVideoStabilizationModeMode", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PictureSettingsVideoStabilizationModeMode_rosparam_value_);
      }
    }
  }
};  // PictureSettingsVideoStabilizationMode

class PictureSettingsVideoRecordingMode : public AbstractSetting
{
private:
  int32_t PictureSettingsVideoRecordingModeMode_bebop_value_;
  bool PictureSettingsVideoRecordingModeMode_bebop_sent_;

public:
  explicit PictureSettingsVideoRecordingMode(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED, priv_nh)
      , PictureSettingsVideoRecordingModeMode_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PictureSettingsVideoRecordingModeMode != PictureSettingsVideoRecordingModeMode_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PictureSettingsVideoRecordingModeMode changed!");
      changed = true;
    }
    all_inited &= PictureSettingsVideoRecordingModeMode_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PictureSettingsVideoRecordingMode was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PictureSettingsVideoRecordingMode changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPictureSettingsVideoRecordingMode(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE>(config.PictureSettingsVideoRecordingModeMode)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PictureSettingsVideoRecordingMode::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE, arg);
    if (arg)
    {
      PictureSettingsVideoRecordingModeMode_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PictureSettingsVideoRecordingModeMode recved: " << static_cast<int32_t>(arg->value.I32));
      PictureSettingsVideoRecordingModeMode_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PictureSettingsVideoRecordingModeMode exists in params ...");
      if (!priv_nh_.hasParam("PictureSettingsVideoRecordingModeMode"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PictureSettingsVideoRecordingModeMode", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PictureSettingsVideoRecordingModeMode_rosparam_value_);
      }
    }
  }
};  // PictureSettingsVideoRecordingMode

class PictureSettingsVideoFramerate : public AbstractSetting
{
private:
  int32_t PictureSettingsVideoFramerateFramerate_bebop_value_;
  bool PictureSettingsVideoFramerateFramerate_bebop_sent_;

public:
  explicit PictureSettingsVideoFramerate(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED, priv_nh)
      , PictureSettingsVideoFramerateFramerate_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PictureSettingsVideoFramerateFramerate != PictureSettingsVideoFramerateFramerate_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PictureSettingsVideoFramerateFramerate changed!");
      changed = true;
    }
    all_inited &= PictureSettingsVideoFramerateFramerate_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PictureSettingsVideoFramerate was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PictureSettingsVideoFramerate changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPictureSettingsVideoFramerate(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE>(config.PictureSettingsVideoFramerateFramerate)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PictureSettingsVideoFramerate::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE, arg);
    if (arg)
    {
      PictureSettingsVideoFramerateFramerate_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PictureSettingsVideoFramerateFramerate recved: " << static_cast<int32_t>(arg->value.I32));
      PictureSettingsVideoFramerateFramerate_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PictureSettingsVideoFramerateFramerate exists in params ...");
      if (!priv_nh_.hasParam("PictureSettingsVideoFramerateFramerate"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PictureSettingsVideoFramerateFramerate", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PictureSettingsVideoFramerateFramerate_rosparam_value_);
      }
    }
  }
};  // PictureSettingsVideoFramerate

class PictureSettingsVideoResolutions : public AbstractSetting
{
private:
  int32_t PictureSettingsVideoResolutionsType_bebop_value_;
  bool PictureSettingsVideoResolutionsType_bebop_sent_;

public:
  explicit PictureSettingsVideoResolutions(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED, priv_nh)
      , PictureSettingsVideoResolutionsType_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.PictureSettingsVideoResolutionsType != PictureSettingsVideoResolutionsType_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "PictureSettingsVideoResolutionsType changed!");
      changed = true;
    }
    all_inited &= PictureSettingsVideoResolutionsType_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of PictureSettingsVideoResolutions was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending PictureSettingsVideoResolutions changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendPictureSettingsVideoResolutions(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE>(config.PictureSettingsVideoResolutionsType)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "PictureSettingsVideoResolutions::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE, arg);
    if (arg)
    {
      PictureSettingsVideoResolutionsType_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for PictureSettingsVideoResolutionsType recved: " << static_cast<int32_t>(arg->value.I32));
      PictureSettingsVideoResolutionsType_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if PictureSettingsVideoResolutionsType exists in params ...");
      if (!priv_nh_.hasParam("PictureSettingsVideoResolutionsType"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("PictureSettingsVideoResolutionsType", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << PictureSettingsVideoResolutionsType_rosparam_value_);
      }
    }
  }
};  // PictureSettingsVideoResolutions

class GPSSettingsHomeType : public AbstractSetting
{
private:
  int32_t GPSSettingsHomeTypeType_bebop_value_;
  bool GPSSettingsHomeTypeType_bebop_sent_;

public:
  explicit GPSSettingsHomeType(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED, priv_nh)
      , GPSSettingsHomeTypeType_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.GPSSettingsHomeTypeType != GPSSettingsHomeTypeType_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "GPSSettingsHomeTypeType changed!");
      changed = true;
    }
    all_inited &= GPSSettingsHomeTypeType_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of GPSSettingsHomeType was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending GPSSettingsHomeType changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendGPSSettingsHomeType(bebop_ctrl_ptr_->aRDrone3
        , static_cast<eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE>(config.GPSSettingsHomeTypeType)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "GPSSettingsHomeType::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE, arg);
    if (arg)
    {
      GPSSettingsHomeTypeType_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for GPSSettingsHomeTypeType recved: " << static_cast<int32_t>(arg->value.I32));
      GPSSettingsHomeTypeType_bebop_value_ = static_cast<int32_t>(arg->value.I32);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if GPSSettingsHomeTypeType exists in params ...");
      if (!priv_nh_.hasParam("GPSSettingsHomeTypeType"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("GPSSettingsHomeTypeType", static_cast<int32_t>(arg->value.I32));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << GPSSettingsHomeTypeType_rosparam_value_);
      }
    }
  }
};  // GPSSettingsHomeType

class GPSSettingsReturnHomeDelay : public AbstractSetting
{
private:
  int32_t GPSSettingsReturnHomeDelayDelay_bebop_value_;
  bool GPSSettingsReturnHomeDelayDelay_bebop_sent_;

public:
  explicit GPSSettingsReturnHomeDelay(ros::NodeHandle& priv_nh)
    : AbstractSetting(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED, priv_nh)
      , GPSSettingsReturnHomeDelayDelay_bebop_sent_(false)
  {}

  // Runs in Nodelet's main thread's context (Dynamic Reconfigure Update Callback)
  void UpdateBebopFromROS(const BebopArdrone3Config &config, const ARCONTROLLER_Device_t* bebop_ctrl_ptr_)
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    bool changed = false;
    bool all_inited = true;

    // This will likely fail for float or double values
    if ((config.GPSSettingsReturnHomeDelayDelay != GPSSettingsReturnHomeDelayDelay_bebop_value_))
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "GPSSettingsReturnHomeDelayDelay changed!");
      changed = true;
    }
    all_inited &= GPSSettingsReturnHomeDelayDelay_bebop_sent_;

    if (changed && !all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_ERROR, "CB",
        "Value of GPSSettingsReturnHomeDelay was not initialized either by Bebop or Params.");
    }

    if (changed && all_inited)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB",
        "Sending GPSSettingsReturnHomeDelay changes to bebop");

      bebop_ctrl_ptr_->aRDrone3->sendGPSSettingsReturnHomeDelay(bebop_ctrl_ptr_->aRDrone3
        , (config.GPSSettingsReturnHomeDelayDelay)
      );
    }
  }

  // Runs in SDK's CommandReceivedCallback's context
  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB",
        "GPSSettingsReturnHomeDelay::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY, arg);
    if (arg)
    {
      GPSSettingsReturnHomeDelayDelay_bebop_sent_ = true;
      ROS_INFO_STREAM("Value for GPSSettingsReturnHomeDelayDelay recved: " << static_cast<int32_t>(arg->value.U16));
      GPSSettingsReturnHomeDelayDelay_bebop_value_ = static_cast<int32_t>(arg->value.U16);

      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "Checking if GPSSettingsReturnHomeDelayDelay exists in params ...");
      if (!priv_nh_.hasParam("GPSSettingsReturnHomeDelayDelay"))
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  No");
        priv_nh_.setParam("GPSSettingsReturnHomeDelayDelay", static_cast<int32_t>(arg->value.U16));
      }
      else
      {
        ARSAL_PRINT(ARSAL_PRINT_INFO, "CB", "  Yes");
        //ROS_INFO_STREAM("New value for ros interanal variable: " << GPSSettingsReturnHomeDelayDelay_rosparam_value_);
      }
    }
  }
};  // GPSSettingsReturnHomeDelay

}  // namespace cb
}  // namespace bebop_driver
#endif  // BEBOP_AUTONOMY_AUTOGENERATED_Ardrone3_SETTING_CALLBACKS_H
