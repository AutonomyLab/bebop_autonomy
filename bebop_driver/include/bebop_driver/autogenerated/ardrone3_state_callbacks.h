/**
Software License Agreement (BSD)

\file      ARDrone3_state_callbacks.h
\authors   Mani Monajjemi <mmonajje@sfu.ca>
\copyright Copyright (c) 2015, Autonomy Lab (Simon Fraser University), All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that
the following conditions are met:
 * Redistributions of source code must retain the above copyright notice, this list of conditions and the
   following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
   following disclaimer in the documentation and/or other materials provided with the distribution.
 * Neither the name of Autonomy Lab nor the names of its contributors may be used to endorse or promote
   products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WAR-
RANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, IN-
DIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * ARDrone3_state_callbacks.h
 * auto-generated from https://raw.githubusercontent.com/Parrot-Developers/libARCommands/5898658a925245555153459ea4684aa87f220e07/Xml/ARDrone3_commands.xml
 * Do not modify this file by hand. Check scripts/meta folder for generator files.
 */

#ifndef BEBOP_AUTONOMY_AUTOGENERATED_ARDrone3_STATE_CALLBACKS_H
#define BEBOP_AUTONOMY_AUTOGENERATED_ARDrone3_STATE_CALLBACKS_H

extern "C"
{
  #include "libARSAL/ARSAL.h"
  #include "libARController/ARController.h"
}

#include "bebop_driver/autogenerated/callbacks_common.h"
#include "bebop_driver/BebopArdrone3Config.h"

#include "bebop_msgs/Ardrone3MediaRecordStatePictureStateChanged.h"
#include "bebop_msgs/Ardrone3MediaRecordStateVideoStateChanged.h"
#include "bebop_msgs/Ardrone3MediaRecordStatePictureStateChangedV2.h"
#include "bebop_msgs/Ardrone3MediaRecordStateVideoStateChangedV2.h"
#include "bebop_msgs/Ardrone3PilotingStateFlatTrimChanged.h"
#include "bebop_msgs/Ardrone3PilotingStateFlyingStateChanged.h"
#include "bebop_msgs/Ardrone3PilotingStateAlertStateChanged.h"
#include "bebop_msgs/Ardrone3PilotingStateNavigateHomeStateChanged.h"
#include "bebop_msgs/Ardrone3PilotingStatePositionChanged.h"
#include "bebop_msgs/Ardrone3PilotingStateSpeedChanged.h"
#include "bebop_msgs/Ardrone3PilotingStateAttitudeChanged.h"
#include "bebop_msgs/Ardrone3PilotingStateAutoTakeOffModeChanged.h"
#include "bebop_msgs/Ardrone3PilotingStateAltitudeChanged.h"
#include "bebop_msgs/Ardrone3NetworkStateWifiScanListChanged.h"
#include "bebop_msgs/Ardrone3NetworkStateAllWifiScanChanged.h"
#include "bebop_msgs/Ardrone3NetworkStateWifiAuthChannelListChanged.h"
#include "bebop_msgs/Ardrone3NetworkStateAllWifiAuthChannelChanged.h"
#include "bebop_msgs/Ardrone3MediaStreamingStateVideoEnableChanged.h"
#include "bebop_msgs/Ardrone3CameraStateOrientation.h"
#include "bebop_msgs/Ardrone3CameraStatedefaultCameraOrientation.h"
#include "bebop_msgs/Ardrone3AntiflickeringStateelectricFrequencyChanged.h"
#include "bebop_msgs/Ardrone3AntiflickeringStatemodeChanged.h"
#include "bebop_msgs/Ardrone3GPSStateNumberOfSatelliteChanged.h"
#include "bebop_msgs/Ardrone3GPSStateHomeTypeAvailabilityChanged.h"
#include "bebop_msgs/Ardrone3GPSStateHomeTypeChosenChanged.h"
#include "bebop_msgs/Ardrone3PROStateFeatures.h"

namespace bebop_driver
{
namespace cb
{


// @deprecated State of picture recording
class Ardrone3MediaRecordStatePictureStateChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3MediaRecordStatePictureStateChanged::Ptr msg_ptr;

public:

  Ardrone3MediaRecordStatePictureStateChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED)
  {
    if (priv_nh.getParam("states/enable_mediarecordstate_picturestatechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3MediaRecordStatePictureStateChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3MediaRecordStatePictureStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStatePictureStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3MediaRecordStatePictureStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID, arg);
    if (arg)
    {
      msg_ptr->mass_storage_id = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaRecordStatePictureStateChanged


// @deprecated State of video recording
class Ardrone3MediaRecordStateVideoStateChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3MediaRecordStateVideoStateChanged::Ptr msg_ptr;

public:

  Ardrone3MediaRecordStateVideoStateChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED)
  {
    if (priv_nh.getParam("states/enable_mediarecordstate_videostatechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3MediaRecordStateVideoStateChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3MediaRecordStateVideoStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStateVideoStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3MediaRecordStateVideoStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID, arg);
    if (arg)
    {
      msg_ptr->mass_storage_id = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaRecordStateVideoStateChanged


// State of device picture recording changed
class Ardrone3MediaRecordStatePictureStateChangedV2 : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3MediaRecordStatePictureStateChangedV2::Ptr msg_ptr;

public:

  Ardrone3MediaRecordStatePictureStateChangedV2(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2)
  {
    if (priv_nh.getParam("states/enable_mediarecordstate_picturestatechangedv2", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3MediaRecordStatePictureStateChangedV2>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3MediaRecordStatePictureStateChangedV2::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStatePictureStateChangedV2::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3MediaRecordStatePictureStateChangedV2());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaRecordStatePictureStateChangedV2


// State of device video recording changed
class Ardrone3MediaRecordStateVideoStateChangedV2 : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3MediaRecordStateVideoStateChangedV2::Ptr msg_ptr;

public:

  Ardrone3MediaRecordStateVideoStateChangedV2(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2)
  {
    if (priv_nh.getParam("states/enable_mediarecordstate_videostatechangedv2", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3MediaRecordStateVideoStateChangedV2>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3MediaRecordStateVideoStateChangedV2::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaRecordStateVideoStateChangedV2::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3MediaRecordStateVideoStateChangedV2());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR, arg);
    if (arg)
    {
      msg_ptr->error = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaRecordStateVideoStateChangedV2


// Drone acknowledges that flat trim was correctly processed
class Ardrone3PilotingStateFlatTrimChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStateFlatTrimChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateFlatTrimChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLATTRIMCHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_flattrimchanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStateFlatTrimChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStateFlatTrimChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateFlatTrimChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStateFlatTrimChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateFlatTrimChanged


// Drone flying state changed
class Ardrone3PilotingStateFlyingStateChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStateFlyingStateChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateFlyingStateChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_flyingstatechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStateFlyingStateChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStateFlyingStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateFlyingStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStateFlyingStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateFlyingStateChanged


// Drone alert state changed
class Ardrone3PilotingStateAlertStateChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStateAlertStateChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateAlertStateChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_alertstatechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStateAlertStateChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStateAlertStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAlertStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStateAlertStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateAlertStateChanged


// Navigating home state
class Ardrone3PilotingStateNavigateHomeStateChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStateNavigateHomeStateChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateNavigateHomeStateChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_navigatehomestatechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStateNavigateHomeStateChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStateNavigateHomeStateChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateNavigateHomeStateChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStateNavigateHomeStateChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON, arg);
    if (arg)
    {
      msg_ptr->reason = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateNavigateHomeStateChanged


// Drone position changed
class Ardrone3PilotingStatePositionChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStatePositionChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStatePositionChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_positionchanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStatePositionChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStatePositionChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStatePositionChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStatePositionChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE, arg);
    if (arg)
    {
      msg_ptr->latitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE, arg);
    if (arg)
    {
      msg_ptr->longitude = arg->value.Double;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE, arg);
    if (arg)
    {
      msg_ptr->altitude = arg->value.Double;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStatePositionChanged


// Drone speed changed
class Ardrone3PilotingStateSpeedChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStateSpeedChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateSpeedChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_speedchanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStateSpeedChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStateSpeedChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateSpeedChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStateSpeedChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX, arg);
    if (arg)
    {
      msg_ptr->speedX = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY, arg);
    if (arg)
    {
      msg_ptr->speedY = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ, arg);
    if (arg)
    {
      msg_ptr->speedZ = arg->value.Float;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateSpeedChanged


// Drone attitude changed
class Ardrone3PilotingStateAttitudeChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStateAttitudeChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateAttitudeChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_attitudechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStateAttitudeChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStateAttitudeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAttitudeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStateAttitudeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL, arg);
    if (arg)
    {
      msg_ptr->roll = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH, arg);
    if (arg)
    {
      msg_ptr->pitch = arg->value.Float;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW, arg);
    if (arg)
    {
      msg_ptr->yaw = arg->value.Float;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateAttitudeChanged


// @deprecated Status of the drone3 automatic take off mode
class Ardrone3PilotingStateAutoTakeOffModeChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStateAutoTakeOffModeChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateAutoTakeOffModeChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_autotakeoffmodechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStateAutoTakeOffModeChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStateAutoTakeOffModeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAutoTakeOffModeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStateAutoTakeOffModeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE, arg);
    if (arg)
    {
      msg_ptr->state = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateAutoTakeOffModeChanged


// Drone altitude changed
class Ardrone3PilotingStateAltitudeChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PilotingStateAltitudeChanged::Ptr msg_ptr;

public:

  Ardrone3PilotingStateAltitudeChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED)
  {
    if (priv_nh.getParam("states/enable_pilotingstate_altitudechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PilotingStateAltitudeChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PilotingStateAltitudeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PilotingStateAltitudeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PilotingStateAltitudeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE, arg);
    if (arg)
    {
      msg_ptr->altitude = arg->value.Double;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PilotingStateAltitudeChanged


// One scanning result found
class Ardrone3NetworkStateWifiScanListChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3NetworkStateWifiScanListChanged::Ptr msg_ptr;

public:

  Ardrone3NetworkStateWifiScanListChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED)
  {
    if (priv_nh.getParam("states/enable_networkstate_wifiscanlistchanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3NetworkStateWifiScanListChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3NetworkStateWifiScanListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3NetworkStateWifiScanListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3NetworkStateWifiScanListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID, arg);
    if (arg)
    {
      msg_ptr->ssid = arg->value.String;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI, arg);
    if (arg)
    {
      msg_ptr->rssi = arg->value.I16;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND, arg);
    if (arg)
    {
      msg_ptr->band = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL, arg);
    if (arg)
    {
      msg_ptr->channel = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3NetworkStateWifiScanListChanged


// State sent when all scanning result sent
class Ardrone3NetworkStateAllWifiScanChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3NetworkStateAllWifiScanChanged::Ptr msg_ptr;

public:

  Ardrone3NetworkStateAllWifiScanChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFISCANCHANGED)
  {
    if (priv_nh.getParam("states/enable_networkstate_allwifiscanchanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3NetworkStateAllWifiScanChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3NetworkStateAllWifiScanChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3NetworkStateAllWifiScanChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3NetworkStateAllWifiScanChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3NetworkStateAllWifiScanChanged


// Notify of an Authorized Channel.
class Ardrone3NetworkStateWifiAuthChannelListChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3NetworkStateWifiAuthChannelListChanged::Ptr msg_ptr;

public:

  Ardrone3NetworkStateWifiAuthChannelListChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED)
  {
    if (priv_nh.getParam("states/enable_networkstate_wifiauthchannellistchanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3NetworkStateWifiAuthChannelListChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3NetworkStateWifiAuthChannelListChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3NetworkStateWifiAuthChannelListChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3NetworkStateWifiAuthChannelListChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND, arg);
    if (arg)
    {
      msg_ptr->band = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL, arg);
    if (arg)
    {
      msg_ptr->channel = arg->value.U8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT, arg);
    if (arg)
    {
      msg_ptr->in_or_out = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3NetworkStateWifiAuthChannelListChanged


// Notify the end of the list of Authorized wifi Channel.
class Ardrone3NetworkStateAllWifiAuthChannelChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3NetworkStateAllWifiAuthChannelChanged::Ptr msg_ptr;

public:

  Ardrone3NetworkStateAllWifiAuthChannelChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED)
  {
    if (priv_nh.getParam("states/enable_networkstate_allwifiauthchannelchanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3NetworkStateAllWifiAuthChannelChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3NetworkStateAllWifiAuthChannelChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3NetworkStateAllWifiAuthChannelChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3NetworkStateAllWifiAuthChannelChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3NetworkStateAllWifiAuthChannelChanged


// Return video streaming status.
class Ardrone3MediaStreamingStateVideoEnableChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3MediaStreamingStateVideoEnableChanged::Ptr msg_ptr;

public:

  Ardrone3MediaStreamingStateVideoEnableChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED)
  {
    if (priv_nh.getParam("states/enable_mediastreamingstate_videoenablechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3MediaStreamingStateVideoEnableChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3MediaStreamingStateVideoEnableChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3MediaStreamingStateVideoEnableChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3MediaStreamingStateVideoEnableChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED, arg);
    if (arg)
    {
      msg_ptr->enabled = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3MediaStreamingStateVideoEnableChanged


// Camera orientation
class Ardrone3CameraStateOrientation : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3CameraStateOrientation::Ptr msg_ptr;

public:

  Ardrone3CameraStateOrientation(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION)
  {
    if (priv_nh.getParam("states/enable_camerastate_orientation", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3CameraStateOrientation>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3CameraStateOrientation::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3CameraStateOrientation::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3CameraStateOrientation());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT, arg);
    if (arg)
    {
      msg_ptr->tilt = arg->value.I8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN, arg);
    if (arg)
    {
      msg_ptr->pan = arg->value.I8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3CameraStateOrientation


// Orientation of the camera center. This is the value to send when we want to center the camera.
class Ardrone3CameraStatedefaultCameraOrientation : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3CameraStatedefaultCameraOrientation::Ptr msg_ptr;

public:

  Ardrone3CameraStatedefaultCameraOrientation(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION)
  {
    if (priv_nh.getParam("states/enable_camerastate_defaultcameraorientation", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3CameraStatedefaultCameraOrientation>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3CameraStatedefaultCameraOrientation::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3CameraStatedefaultCameraOrientation::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3CameraStatedefaultCameraOrientation());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_TILT, arg);
    if (arg)
    {
      msg_ptr->tilt = arg->value.I8;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_PAN, arg);
    if (arg)
    {
      msg_ptr->pan = arg->value.I8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3CameraStatedefaultCameraOrientation


// Electric frequency of the country determined by the position of the controller
class Ardrone3AntiflickeringStateelectricFrequencyChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3AntiflickeringStateelectricFrequencyChanged::Ptr msg_ptr;

public:

  Ardrone3AntiflickeringStateelectricFrequencyChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED)
  {
    if (priv_nh.getParam("states/enable_antiflickeringstate_electricfrequencychanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3AntiflickeringStateelectricFrequencyChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3AntiflickeringStateelectricFrequencyChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3AntiflickeringStateelectricFrequencyChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3AntiflickeringStateelectricFrequencyChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY, arg);
    if (arg)
    {
      msg_ptr->frequency = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3AntiflickeringStateelectricFrequencyChanged


// Anti flickering mode
class Ardrone3AntiflickeringStatemodeChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3AntiflickeringStatemodeChanged::Ptr msg_ptr;

public:

  Ardrone3AntiflickeringStatemodeChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED)
  {
    if (priv_nh.getParam("states/enable_antiflickeringstate_modechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3AntiflickeringStatemodeChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3AntiflickeringStatemodeChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3AntiflickeringStatemodeChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3AntiflickeringStatemodeChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE, arg);
    if (arg)
    {
      msg_ptr->mode = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3AntiflickeringStatemodeChanged


// The number of satellite used to compute the gps position
class Ardrone3GPSStateNumberOfSatelliteChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3GPSStateNumberOfSatelliteChanged::Ptr msg_ptr;

public:

  Ardrone3GPSStateNumberOfSatelliteChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED)
  {
    if (priv_nh.getParam("states/enable_gpsstate_numberofsatellitechanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3GPSStateNumberOfSatelliteChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3GPSStateNumberOfSatelliteChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3GPSStateNumberOfSatelliteChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3GPSStateNumberOfSatelliteChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE, arg);
    if (arg)
    {
      msg_ptr->numberOfSatellite = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3GPSStateNumberOfSatelliteChanged


// Availability of the return home types in a map : for each type other args will be sent by the drone
class Ardrone3GPSStateHomeTypeAvailabilityChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3GPSStateHomeTypeAvailabilityChanged::Ptr msg_ptr;

public:

  Ardrone3GPSStateHomeTypeAvailabilityChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED)
  {
    if (priv_nh.getParam("states/enable_gpsstate_hometypeavailabilitychanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3GPSStateHomeTypeAvailabilityChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3GPSStateHomeTypeAvailabilityChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3GPSStateHomeTypeAvailabilityChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3GPSStateHomeTypeAvailabilityChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE, arg);
    if (arg)
    {
      msg_ptr->type = arg->value.I32;
    }

    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE, arg);
    if (arg)
    {
      msg_ptr->available = arg->value.U8;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3GPSStateHomeTypeAvailabilityChanged


// The return home type chosen
class Ardrone3GPSStateHomeTypeChosenChanged : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3GPSStateHomeTypeChosenChanged::Ptr msg_ptr;

public:

  Ardrone3GPSStateHomeTypeChosenChanged(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED)
  {
    if (priv_nh.getParam("states/enable_gpsstate_hometypechosenchanged", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3GPSStateHomeTypeChosenChanged>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3GPSStateHomeTypeChosenChanged::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3GPSStateHomeTypeChosenChanged::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3GPSStateHomeTypeChosenChanged());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE, arg);
    if (arg)
    {
      msg_ptr->type = arg->value.I32;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3GPSStateHomeTypeChosenChanged


// Features enabled
class Ardrone3PROStateFeatures : public AbstractState
{
private:
  ::bebop_msgs::Ardrone3PROStateFeatures::Ptr msg_ptr;

public:

  Ardrone3PROStateFeatures(::ros::NodeHandle& nh, ::ros::NodeHandle& priv_nh, const ::std::string& topic)
    : AbstractState(ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES)
  {
    if (priv_nh.getParam("states/enable_prostate_features", pub_enabled_) && pub_enabled_)
    {
      ARSAL_PRINT(ARSAL_PRINT_INFO, "CB" , "[STATES] Enabling %s", topic.c_str());
      ros_pub_ = nh.advertise<bebop_msgs::Ardrone3PROStateFeatures>(topic, 10, true);
    } // pub_enabled_ is false
  }

  ::bebop_msgs::Ardrone3PROStateFeatures::ConstPtr GetDataCstPtr() const
  {
    ::boost::lock_guard<boost::mutex> lock(mutex_);
    return msg_ptr;
  }

  void Update(const ARCONTROLLER_DICTIONARY_ARG_t *arguments, const ::ros::Time& t)
  {
    if (arguments == NULL)
    {
      ARSAL_PRINT(ARSAL_PRINT_WARNING, "CB", "Ardrone3PROStateFeatures::Update() arguments is NULL");
      return;
    }

    ::boost::lock_guard<boost::mutex> lock(mutex_);
    msg_ptr.reset(new ::bebop_msgs::Ardrone3PROStateFeatures());
    msg_ptr->header.stamp = t;
    msg_ptr->header.frame_id = "base_link";


    arg = NULL;
    HASH_FIND_STR (arguments, ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES, arg);
    if (arg)
    {
      msg_ptr->features = arg->value.U64;
    }

    if (pub_enabled_) ros_pub_.publish(msg_ptr);
  }

};  // Ardrone3PROStateFeatures


}  // namespace cb
}  // namespace bebop_driver
#endif  // BEBOP_AUTONOMY_AUTOGENERATED_ARDrone3_STATE_CALLBACKS_H